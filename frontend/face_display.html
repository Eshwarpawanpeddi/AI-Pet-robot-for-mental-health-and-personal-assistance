<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Pet Robot Face - Fullscreen Edition</title>
    <link rel="stylesheet" href="/static/styles.css">
</head>
<body>
    <div class="robot-container">
        <canvas id="faceCanvas" class="face-canvas"></canvas>
        
        <div class="status-bar">
            <div class="status-item">User Feel: <span id="userEmotion" style="color:#4ade80">Neutral</span></div>
            <div class="status-item">Robot Feel: <span id="robotEmotion" style="color:#fbbf24">Neutral</span></div>
            <div class="status-item">Battery: <span id="batteryLevel">100</span>%</div>
        </div>

        <div class="control-panel">
            <button class="btn" onclick="sendText('How are you?')">üëã Say Hello</button>
            <button class="btn" onclick="changeEmotion('happy')">üòä Happy</button>
            <button class="btn" onclick="changeEmotion('sad')">üò¢ Sad (Cry)</button>
            <button class="btn" onclick="changeEmotion('angry')">üí¢ Angry</button>
            <button class="btn" onclick="changeEmotion('neutral')">üòê Neutral</button>
        </div>
    </div>

    <script>
        class ExpressiveEyesRenderer {
            constructor(canvasId) {
                this.canvas = document.getElementById(canvasId);
                this.ctx = this.canvas.getContext('2d');
                this.emotion = 'neutral';
                this.eyeOpen = 1.0;
                this.time = 0;
                this.tears = [];
                
                // Initialize sizing
                this.resize();
                window.addEventListener('resize', () => this.resize());
                
                this.animate();
            }

            resize() {
                // Adjusts the internal drawing resolution to match the screen
                this.canvas.width = this.canvas.clientWidth;
                this.canvas.height = this.canvas.clientHeight;
                this.centerX = this.canvas.width / 2;
                this.centerY = this.canvas.height / 2;
            }

            animate() {
                this.time += 0.05;
                this.eyeOpen = (this.time % 5 < 0.15) ? 0.1 : 1.0;
                this.draw();
                requestAnimationFrame(() => this.animate());
            }

            draw() {
                this.ctx.fillStyle = '#000';
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                
                const color = this.getEmotionColor();
                
                if (this.emotion === 'sad') {
                    this.drawTears();
                }

                // Spacing between eyes scales with screen width
                const eyeSpacing = this.canvas.width * 0.16;
                this.drawEye(this.centerX - eyeSpacing, this.centerY, color, 'L');
                this.drawEye(this.centerX + eyeSpacing, this.centerY, color, 'R');
            }

            drawTears() {
                const eyeSpacing = this.canvas.width * 0.16;
                if (Math.random() > 0.92) {
                    this.tears.push({x: (this.centerX - eyeSpacing) + (Math.random()*30-15), y: this.centerY + 20, speed: Math.random()*2+2});
                    this.tears.push({x: (this.centerX + eyeSpacing) + (Math.random()*30-15), y: this.centerY + 20, speed: Math.random()*2+2});
                }

                this.ctx.fillStyle = 'rgba(74, 144, 226, 0.7)';
                for (let i = 0; i < this.tears.length; i++) {
                    let t = this.tears[i];
                    t.y += t.speed;
                    this.ctx.beginPath();
                    this.ctx.arc(t.x, t.y, 4, 0, Math.PI * 2);
                    this.ctx.fill();
                    
                    if (t.y > this.canvas.height) {
                        this.tears.splice(i, 1);
                        i--;
                    }
                }
            }

            drawEye(x, y, color, side) {
                this.ctx.save();
                this.ctx.translate(x, y);
                this.ctx.fillStyle = color;
                this.ctx.shadowBlur = 20;
                this.ctx.shadowColor = color;

                // Scale the eye size based on screen height
                const baseSize = this.canvas.height * 0.12;

                if (this.emotion === 'happy') {
                    this.ctx.lineWidth = baseSize * 0.25;
                    this.ctx.strokeStyle = color;
                    this.ctx.lineCap = 'round';
                    this.ctx.beginPath();
                    this.ctx.arc(0, baseSize * 0.2, baseSize * 0.6, Math.PI, 0, false);
                    this.ctx.stroke();
                } else if (this.emotion === 'angry') {
                    this.ctx.strokeStyle = color;
                    this.ctx.lineWidth = baseSize * 0.2;
                    this.ctx.lineCap = 'round';
                    this.ctx.beginPath();
                    if (side === 'L') {
                        this.ctx.moveTo(-baseSize, -baseSize);
                        this.ctx.lineTo(baseSize * 0.5, -baseSize * 0.4);
                    } else {
                        this.ctx.moveTo(baseSize, -baseSize);
                        this.ctx.lineTo(-baseSize * 0.5, -baseSize * 0.4);
                    }
                    this.ctx.stroke();
                    this.drawPill(baseSize * 0.9, baseSize * 1.5);
                } else if (this.emotion === 'sad') {
                    this.ctx.rotate(side === 'L' ? -0.25 : 0.25);
                    this.drawPill(baseSize * 0.8, baseSize * 1.1 * this.eyeOpen);
                } else {
                    this.drawPill(baseSize * 0.9, baseSize * 1.5 * this.eyeOpen);
                }
                this.ctx.restore();
            }

            drawPill(w, h) {
                this.ctx.beginPath();
                this.ctx.roundRect(-w/2, -h/2, w, h, w/2);
                this.ctx.fill();
            }

            getEmotionColor() {
                const colors = {
                    'happy': '#FFD700', 'sad': '#4A90E2', 'angry': '#FF5050', 'neutral': '#4ADE80'
                };
                return colors[this.emotion] || colors['neutral'];
            }
        }

        const eyes = new ExpressiveEyesRenderer('faceCanvas');

        const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
        const ws = new WebSocket(`${protocol}//${window.location.host}/ws/control`);

        ws.onmessage = (event) => {
            const data = JSON.parse(event.data);
            if (data.type === 'state') {
                const state = data.data;
                eyes.emotion = state.emotion;
                document.getElementById('userEmotion').textContent = state.user_emotion;
                document.getElementById('robotEmotion').textContent = state.emotion;
                document.getElementById('batteryLevel').textContent = state.battery_level;
            }
        };

        function changeEmotion(emo) {
            eyes.emotion = emo;
            ws.send(JSON.stringify({ type: 'emotion', emotion: emo }));
        }

        function sendText(txt) {
            ws.send(JSON.stringify({ type: 'text', text: txt }));
        }
    </script>
</body>
</html>